const fs = require('fs');
const crypto = require('crypto');
const https = require('https');
const path = require('path');
const htmlMinify = require('html-minifier').minify;
const jsMinify = require('uglify-js').minify;

const argFile = process.argv[2];
const fileName = path.normalize(argFile);
const dirName = path.dirname(fileName);
const DEBUG = (process.argv[3]?.toLowerCase() === 'debug')

const htmlMinifyConf = {
    collapseInlineTagWhitespace: false,
    collapseWhitespace: true,
    decodeEntities: true,
    includeAutoGeneratedTags: false,
    minifyCSS: true,
    minifyJS: true,
    removeAttributeQuotes: true,
    removeComments: true,
    removeEmptyAttributes: true,
    removeEmptyElements: false, // kills font-awesome if true
    removeOptionalTags: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    sortAttributes: true,
    sortClassName: true,
    trimCustomFragments: true,
    useShortDoctype: true,
}

const minifyJsConf = {
    module: false,
    toplevel: true,
    v8: true,
    ie: true,
    webkit: true,
}

const exclude_mini_js = [
    'wp-content/plugins/megamenu/js/maxmegamenu.js',
    'wp-includes/js/jquery/jquery.min.js',
    'wp-includes/js/hoverIntent.min.js',
    'wp-content/themes/eisai-child/assets/js/font-awesome.js',
];
//const exclude_css = [ './wp-content/plugins/megamenu/css/mega-menu-special.css' ]

if (!fileName) {
    console.error(`Usage: ${process.argv[0]} ${process.argv[1]} [file]`);
    process.exit(1);
}

let mainHtml = fs.readFileSync(fileName).toString(); // Get html-file into a string

const download = (url) => new Promise((resolve, reject) => {
    let result = '';
    https.get(url, function(response) {
        response.on('data', (d) => {
            result += d.toString();
        });
        // after download completed close filestream
        response.on("finish", () => {
            resolve(result);
        });
     });
})


const fixRootPath = (path) => {
    const npath = path.replace(/^.*\/wp-content/, 'wp-content').replace(/^.*\/wp-includes/g, 'wp-includes').replace(/^\.?\//, '');
    return `./site/${npath}`;
}

const main = async () => {
    console.log(`Preparing ${fileName}`);

    console.log(` * Baking CSS`);
    const cssImports = mainHtml.matchAll(/<link rel=["']stylesheet['"] .*?href=["']\/?(.*?)['"].*?\/?>/g)
    Array.from(cssImports).forEach(cssImport => {
        if (cssImport[1].indexOf('http') !== -1) {
            // webfile - skip for now
        } else {
            const cssFileName = fixRootPath(cssImport[1].replace(/%3F.*/, '')).replace(/\?.*/, '');
            if (fs.existsSync(cssFileName)) {
                const css = fs.readFileSync(cssFileName).toString()
                mainHtml = mainHtml.replace(cssImport[0], `\n<!-- ${cssFileName} -->\n<style>${css}</style>\n`);
            } else {
                //console.log(` ! Skipping '${cssFileName}', not found in local filesystem`)
            }
        }
    })

    const jsImports = Array.from(mainHtml.matchAll(/<script .*?src=["']\/?(.*?)['"].*?<\/script>/g));

    console.log(` * Baking JS`);

    for (const jsImport of jsImports)  {
        let jsFile = jsImport[1].replace('%3F', '?')

        // localfile
        if (jsFile.indexOf('?') !== -1) {
            // If there's a query parameter remove it
            jsFile = `./${jsFile.replace(/\?.*/, '')}`;
        }

        if (jsFile.indexOf('http') !== -1) {
            console.log(` * Skipping ${jsFile}, has http in it`);
            continue;
            // FIXME: Skipping web downloadable files for now.
            // console.log(` * Downloading ${jsFile}, has http in it`)
            // const content = await download(jsFile);
            // mainHtml = mainHtml.replace(jsImport[0], `\n\n<!-- ${jsFile} -->\n<script>\n${content}\n</script>\n`);
        }

        jsFileName = path.normalize(fixRootPath(jsFile));

        if (!fs.existsSync(jsFileName)) {
            console.log(` * Skipping ${jsFile}, not found in local filesystem`)
        } else {
            try {
                // Skip minifying some files
                if (exclude_mini_js.includes(jsFile)) {
                    console.log(` * processing ${jsFile} (mini: NO)`)
                } else {
                    console.log(` * processing ${jsFile} (mini: YES)`)
                    const js = fs.readFileSync(jsFileName).toString();
                    fs.writeFileSync(jsFileName, jsMinify(js).code.toString());
                }

                // Pga någon bug har jag tillfälligt avaktiverat script-integrity kontrollen.
                // den hash som skrivs in i filerna (och antar genereras av nodejs) stämmer inte
                // med den hash man får genom att köra manuellt:
                // cat font-awesome.js | openssl dgst -sha384 --binary | openssl base64 -A
                // const hash = crypto.createHash('sha384').update(miniJs).digest('base64')
                // mainHtml = mainHtml.replace(jsImport[0], `\n\n<!-- ${jsFile} -->\n<script integrity="sha384-${hash}" src="/${jsFile}"></script>\n`);
                mainHtml = mainHtml.replace(jsImport[0], `\n\n<!-- ${jsFile} -->\n<script src="/${jsFile}"></script>\n`);
            } catch (err) {
                console.error(` E ${err.message} ${jsFile}`);
                console.error(err)
                console.error("\n")
            }
        }
    };

    if (!DEBUG) {
        console.log(` * Minifying HTML`);
        const miniHtml = htmlMinify(mainHtml, htmlMinifyConf) // DANGEROUS until we have all scripts and styles inline --->>> .replace(/<\/style><style>/, " ").replace(/<\/script><script>/, " ");

        console.log(` * Writing`)
        fs.writeFileSync(fileName,miniHtml);
    } else {
        console.log(` * DEBUG`)
        fs.writeFileSync(fileName, mainHtml);
    }

}


main()